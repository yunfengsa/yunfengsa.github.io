---
layout: post
title: "Event Bus一个安卓的优化方式"
date: 2015-12-29 10:13:02 +0800
comments: true
categories: android
tags: [android,EventBus]
---

##概述
EventBus是一个针对android优化的发布/订阅事件总线.主要目的是替代Itent.handler,broadcast在Fragment activity Service之间进行*线程消息传递*.
优点:开销小,代码优雅,解耦

[源码库点此](https://github.com/greenrobot/EventBus)

###基本工作方式
![eb1](http://7xnvyl.com1.z0.glb.clouddn.com/2015-12-19eventbus.png)


<!--more-->

##实战体验
当点击btn_try按钮的时候,跳转到第二个activity,再点击第二个acitivity上面的First Event按钮的时候向第一个Activity发送消息,当第一个activity接收到消息后,显示Toast,并把textview中内容更新.

如下图

![eb2](http://img.blog.csdn.net/20141102142444304)

* 基本框架略过(这个很简单)
* 重点是EventBus的基本使用

1.新建一个类(FirstEvent)

```java

public class FirstEvent {  
  
    private String mMsg;  
    public FirstEvent(String msg) {  
        // TODO Auto-generated constructor stub  
        mMsg = msg;  
    }  
    public String getMsg(){  
        return mMsg;  
    }  
}  

```

2.很显然我们需要在第一个activity中订阅注册

```java

import com.harvic.other.FirstEvent;  
  
import de.greenrobot.event.EventBus;  
import android.app.Activity;  
import android.content.Intent;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.View;  
import android.widget.Button;  
import android.widget.TextView;  
import android.widget.Toast;  
  
public class MainActivity extends Activity {  
  
    Button btn;  
    TextView tv;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
                //注册EventBus  
        EventBus.getDefault().register(this);  
  
        btn = (Button) findViewById(R.id.btn_try);  
        tv = (TextView)findViewById(R.id.tv);  
  
        btn.setOnClickListener(new View.OnClickListener() {  
  
            @Override  
            public void onClick(View v) {  
                // TODO Auto-generated method stub  
                Intent intent = new Intent(getApplicationContext(),  
                        SecondActivity.class);  
                startActivity(intent);  
            }  
        });  
    }  
    @Override  
    protected void onDestroy(){  
        super.onDestroy();  
        EventBus.getDefault().unregister(this);//反注册EventBus  
    }  
}  

```

*关于eventbus的获取方式,既可以new 也可以用默认(一般推荐用后者)*

3.消息发送(显然是第二个activity进行)

```java

import com.harvic.other.FirstEvent;  
  
import de.greenrobot.event.EventBus;  
import android.app.Activity;  
import android.os.Bundle;  
import android.view.View;  
import android.widget.Button;  
  
public class SecondActivity extends Activity {  
    private Button btn_FirstEvent;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_second);  
        btn_FirstEvent = (Button) findViewById(R.id.btn_first_event);  
  
        btn_FirstEvent.setOnClickListener(new View.OnClickListener() {  
  
            @Override  
            public void onClick(View v) {  
                // TODO Auto-generated method stub  
                EventBus.getDefault().post(  
                        new FirstEvent("FirstEvent btn clicked"));  
            }  
        });  
    }  
}  

```
4.消息接收

接下来我们需要重写接收函数(在第一个acitivty中),我们暂时先重写onEventMainThread接收消息

```java

public void onEventMainThread(FirstEvent event) {  
  
    String msg = "onEventMainThread收到了消息：" + event.getMsg();  
    Log.d("harvic", msg);  
    tv.setText(msg);  
    Toast.makeText(this, msg, Toast.LENGTH_LONG).show();  
}  

```

基本使用就是这样,很简单 很优雅.

##消息接收的四种方式

我们在例子中用的是其中一个接收函数,其实EventBus共有四种不同的接收函数。

* onEvent
* onEventMainThread
* onEventBackground
* onEventAsync

<font color=red>onEvent: </font>这个方法说明发送者和接收者需要在同一个线程中,即post和onEvent需要在同一个线程中.这就会有一个问题了，如果接收onEvent中有延时操作，很明显会出现分发延迟的现象，所以不要在onEvent执行耗时操作。

<font color=red>onEventMainThread: </font>这个就很好理解了吧,无论实践是从哪个线程中发布出来的,onEventMainThread都会在UI线程执行,所以当然也不能在其中执行耗时操作啦，出现ANR后果自负哦。

<font color=red>onEventBackground: </font>故名思议，不管时间是从主线程post还是从子线程post，onEventBackground都会在子线程执行，如果是子线程post则直接在该子线程中接收执行。

<font color=red>onEventAsync: </font>使用这个函数订阅的时候，无论是在哪种线程中post，都会新创建一个子线程进行执行操作。

###那么问题来了，你怎么知道用哪个函数接收呢？

其实很简单我们在onEvent××（）中，会传进去我们相应的Event比如，我们在例子中的onEventMainThread（）中，传进去的就是FirstEvent event。

**需要注意的是，如果同一个事件被多个函数接收，则每个接收者都会执行！**

##使用没问题了，是不是还是要看看源码呢！

先来register

```java

private synchronized void register(Object subscriber, String methodName, boolean sticky, int priority) {  
        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass(),  
                methodName);  
        for (SubscriberMethod subscriberMethod : subscriberMethods) {  
            subscribe(subscriber, subscriberMethod, sticky, priority);  
        }  
    }  

```

subscriber:就是注册的订阅者

methodName：订阅函数名，默认就是“onEvent”

sticky:表示是否是粘性的，一般默认为false，除非你调用registerSticky方法

priority：事件的优先级，默认就行

接着函数找到所有的订阅方法，然后订阅，

```java

List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass, String eventMethodName) {  
        //通过订阅者类名+"."+"onEvent"创建一个key  
        String key = subscriberClass.getName() + '.' + eventMethodName;  
        List<SubscriberMethod> subscriberMethods;  
        synchronized (methodCache) {  
            //判断是否有缓存，有缓存直接返回缓存  
            subscriberMethods = methodCache.get(key);  
        }  
        //第一次进来subscriberMethods肯定是Null  
        if (subscriberMethods != null) {  
            return subscriberMethods;  
        }  
        subscriberMethods = new ArrayList<SubscriberMethod>();  
        Class<?> clazz = subscriberClass;  
        HashSet<String> eventTypesFound = new HashSet<String>();  
        StringBuilder methodKeyBuilder = new StringBuilder();  
        while (clazz != null) {  
            String name = clazz.getName();  
            //过滤掉系统类  
            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {  
                // Skip system classes, this just degrades performance  
                break;  
            }  
  
            // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)  
            //通过反射，获取到订阅者的所有方法  
            Method[] methods = clazz.getMethods();  
            for (Method method : methods) {  
                String methodName = method.getName();  
                //只找以onEvent开头的方法  
                if (methodName.startsWith(eventMethodName)) {  
                    int modifiers = method.getModifiers();  
                    //判断订阅者是否是public的,并且是否有修饰符，看来订阅者只能是public的，并且不能被final，static等修饰  
                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {  
                        //获得订阅函数的参数  
                        Class<?>[] parameterTypes = method.getParameterTypes();  
                        //看了参数的个数只能是1个  
                        if (parameterTypes.length == 1) {  
                            //获取onEvent后面的部分  
                            String modifierString = methodName.substring(eventMethodName.length());  
                            ThreadMode threadMode;  
                            if (modifierString.length() == 0) {  
                                //订阅函数为onEvnet  
                                //记录线程模型为PostThread,意义就是发布事件和接收事件在同一个线程执行，详细可以参考我对于四个订阅函数不同点分析  
                                threadMode = ThreadMode.PostThread;  
                            } else if (modifierString.equals("MainThread")) {  
                                //对应onEventMainThread  
                                threadMode = ThreadMode.MainThread;  
                            } else if (modifierString.equals("BackgroundThread")) {  
                                //对应onEventBackgrondThread  
                                threadMode = ThreadMode.BackgroundThread;  
                            } else if (modifierString.equals("Async")) {  
                                //对应onEventAsync  
                                threadMode = ThreadMode.Async;  
                            } else {  
                                if (skipMethodVerificationForClasses.containsKey(clazz)) {  
                                    continue;  
                                } else {  
                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);  
                                }  
                            }  
                            //获取参数类型，其实就是接收事件的类型  
                            Class<?> eventType = parameterTypes[0];  
                            methodKeyBuilder.setLength(0);  
                            methodKeyBuilder.append(methodName);  
                            methodKeyBuilder.append('>').append(eventType.getName());  
                            String methodKey = methodKeyBuilder.toString();  
                            if (eventTypesFound.add(methodKey)) {  
                                // Only add if not already found in a sub class  
                                //封装一个订阅方法对象，这个对象包含Method对象，threadMode对象，eventType对象  
                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));  
                            }  
                        }  
                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {  
                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."  
                                + methodName);  
                    }  
                }  
            }  
            //看了还会遍历父类的订阅函数  
            clazz = clazz.getSuperclass();  
        }  
        //最后加入缓存，第二次使用直接从缓存拿  
        if (subscriberMethods.isEmpty()) {  
            throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "  
                    + eventMethodName);  
        } else {  
            synchronized (methodCache) {  
                methodCache.put(key, subscriberMethods);  
            }  
            return subscriberMethods;  
        }  
    }  

```

上述代码注意看注释

接着就会进入subscribe方法

```java

private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) {  
        subscribed = true;  
        //从订阅方法中拿到订阅事件的类型  
        Class<?> eventType = subscriberMethod.eventType;  
        //通过订阅事件类型，找到所有的订阅（Subscription）,订阅中包含了订阅者，订阅方法  
        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);  
        //创建一个新的订阅  
        Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);  
        //将新建的订阅加入到这个事件类型对应的所有订阅列表  
        if (subscriptions == null) {  
            //如果该事件目前没有订阅列表，那么创建并加入该订阅  
            subscriptions = new CopyOnWriteArrayList<Subscription>();  
            subscriptionsByEventType.put(eventType, subscriptions);  
        } else {  
            //如果有订阅列表，检查是否已经加入过  
            for (Subscription subscription : subscriptions) {  
                if (subscription.equals(newSubscription)) {  
                    throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "  
                            + eventType);  
                }  
            }  
        }  
  
        //根据优先级插入订阅  
        int size = subscriptions.size();  
        for (int i = 0; i <= size; i++) {  
            if (i == size || newSubscription.priority > subscriptions.get(i).priority) {  
                subscriptions.add(i, newSubscription);  
                break;  
            }  
        }  
        //将这个订阅事件加入到订阅者的订阅事件列表中  
        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);  
        if (subscribedEvents == null) {  
            subscribedEvents = new ArrayList<Class<?>>();  
            typesBySubscriber.put(subscriber, subscribedEvents);  
        }  
        subscribedEvents.add(eventType);  
        //这个是对粘性事件的，暂时不讨论  
        if (sticky) {  
            Object stickyEvent;  
            synchronized (stickyEvents) {  
                stickyEvent = stickyEvents.get(eventType);  
            }  
            if (stickyEvent != null) {  
                postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());  
            }  
        }  
    }  

```
register的基本流程：

* 找到被注册者中的所有订阅方法。
* 一次遍历订阅方法，找到EventBus中的eventType对应的订阅列表，然后根据当前订阅者和订阅方法创建一个新的订阅到订阅列表。
* 找到Eventbus中的subscriber订阅的事件列表，将eventType加入到事件列表。

所以对于任何一个订阅者，我们可以到找到它的订阅时间类型的列表，然后通过订阅事件类型，可以找到在订阅者中的订阅函数。

最后分析下post

```java

public void post(Object event) {  
        //这个EventBus中只有一个，差不多是个单例吧，具体不用细究  
        PostingThreadState postingState = currentPostingThreadState.get();  
        List<Object> eventQueue = postingState.eventQueue;  
        //将事件放入队列  
        eventQueue.add(event);  
  
        if (postingState.isPosting) {  
            return;  
        } else {  
            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();  
            postingState.isPosting = true;  
            if (postingState.canceled) {  
                throw new EventBusException("Internal error. Abort state was not reset");  
            }  
            try {  
                while (!eventQueue.isEmpty()) {  
                    //分发事件  
                    postSingleEvent(eventQueue.remove(0), postingState);  
                }  
            } finally {  
                postingState.isPosting = false;  
                postingState.isMainThread = false;  
            }  
        }  
    }  

```

```java

private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {  
       Class<? extends Object> eventClass = event.getClass();  
    //找到eventClass对应的事件，包含父类对应的事件和接口对应的事件  
       List<Class<?>> eventTypes = findEventTypes(eventClass);  
       boolean subscriptionFound = false;  
       int countTypes = eventTypes.size();  
       for (int h = 0; h < countTypes; h++) {  
           Class<?> clazz = eventTypes.get(h);  
           CopyOnWriteArrayList<Subscription> subscriptions;  
           synchronized (this) {  
            //找到订阅事件对应的订阅，这个是通过register加入的（还记得吗....）  
               subscriptions = subscriptionsByEventType.get(clazz);  
           }  
           if (subscriptions != null && !subscriptions.isEmpty()) {  
               for (Subscription subscription : subscriptions) {  
                   postingState.event = event;  
                   postingState.subscription = subscription;  
                   boolean aborted = false;  
                   try {  
                    //对每个订阅调用该方法  
                       postToSubscription(subscription, event, postingState.isMainThread);  
                       aborted = postingState.canceled;  
                   } finally {  
                       postingState.event = null;  
                       postingState.subscription = null;  
                       postingState.canceled = false;  
                   }  
                   if (aborted) {  
                       break;  
                   }  
               }  
               subscriptionFound = true;  
           }  
       }  
    //如果没有订阅发现，那么会Post一个NoSubscriberEvent事件  
       if (!subscriptionFound) {  
           Log.d(TAG, "No subscribers registered for event " + eventClass);  
           if (eventClass != NoSubscriberEvent.class && eventClass != SubscriberExceptionEvent.class) {  
               post(new NoSubscriberEvent(this, event));  
           }  
       }  
   }  


```

```java

private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {  
        //第一个参数就是传入的订阅，第二个参数就是对于的分发事件，第三个参数非常关键：是否在主线程  
        switch (subscription.subscriberMethod.threadMode) {  
        //这个threadMode是怎么传入的，仔细想想？是不是根据onEvent,onEventMainThread,onEventBackground,onEventAsync决定的？  
        case PostThread:  
            //直接在本线程中调用订阅函数  
            invokeSubscriber(subscription, event);  
            break;  
        case MainThread:  
            if (isMainThread) {  
                //如果直接在主线程，那么直接在本现场中调用订阅函数  
                invokeSubscriber(subscription, event);  
            } else {  
                //如果不在主线程，那么通过handler实现在主线程中执行，具体我就不跟踪了  
                mainThreadPoster.enqueue(subscription, event);  
            }  
            break;  
        case BackgroundThread:  
            if (isMainThread) {  
                //如果主线程，创建一个runnable丢入线程池中  
                backgroundPoster.enqueue(subscription, event);  
            } else {  
                //如果子线程，则直接调用  
                invokeSubscriber(subscription, event);  
            }  
            break;  
        case Async:  
            //不论什么线程，直接丢入线程池  
            asyncPoster.enqueue(subscription, event);  
            break;  
        default:  
            throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);  
        }  
    }  

```

**最后在postToSubscription中能够看到四种订阅处理方法的区别**

